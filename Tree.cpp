#include <fstream>
#include <iostream>
#include "Tree.h"

//#define DEBUG

Tree::Tree()
{
	pHead = nullptr;
}

//###############################Деструктор дерева, реалезованный через перебор всех узлов###############################
Tree::~Tree()
{
	DeleteTree(pHead);
}
//Реализайия с выводом, удаляемых элементов для 
void Tree::DeleteTree(Node* pTemp)
{
	if (!pTemp->pLeft && !pTemp->pRight) { //Нет способа получить узел ниже, то нынешний узел крайний нижний в этой ветке
#ifdef DEBUG
		std::cout << pTemp->Data << " "; //Вывод нынешнего узла (только в режиме DeBug)
#endif
		delete pTemp;
		return;
	}
	//Поиск крайнего левого нижнего узла, игнорируя правую ветку
	if (pTemp->pLeft)//Узлы левее имеют больший приоритет
		DeleteTree(pTemp->pLeft); //Если есть способ получить узел левее, то нынешний узел не крайний нижний левый

	//Крайний левый нижний узел для данной ветки найден

	if (pTemp->pRight)//Если есть способ получить узел правее (узлов левее больше нет), то нынешний узел не крайний нижний для этой ветки
		DeleteTree(pTemp->pRight); //Вход в правую ветку

#ifdef DEBUG
	std::cout << pTemp->Data << " "; //Вывод нынешнего удаляемого узла (только в режиме DeBug)
#endif
	delete pTemp;
}
//###############################Деструктор дерева, реалезованный через перебор всех узлов###############################


void Tree::readFile(std::ifstream& rf)
{
	int number;
	while (!rf.eof()) {
		rf >> number;
		add(number);
	}
}

//Добавление элемента в дерево с сортировкой (чем меньше число, тем левее в дереве оно расположено)
void Tree::add(int data)
{
	Node* pNode = new Node;//создание вового узла
	pNode->Data = data;		//	┃
	pNode->pLeft = nullptr;	//	┃
	pNode->pRight = nullptr;//	┚

	//Если корня дерева пока нет		┓
	if (!pHead) {					//	┃
		pHead = pNode;//Создание корня	┃
		return;						//	┚
	}

	//###############################Обход дерева до крайнего элемента, подходящего под усовие###############################
	
	//Если значение нынешнего узла меньше добавляеммого значения,
	//		то подходящий крайний элемент находится слева от нынешнего узла (при условии, что слева есть узел)
	
	//Иначе подходящий крайний элемент находится справа от нынешнего узла (при условии, что справа есть узел)
	
	//Если при попытки получить элемент слева от нынешнего получилось nullptr (отцувствие левого элеммента),
	//		то создаётся новый узел. Новый узел будет считаться левым, для нынешнего узла и содержать значение, которое нужно добавить в дерево.
	//		После этого элемент считается добавленным
	
	//Аналогично и для правой ветки
	Node* pTemp = pHead;
	while (pTemp && (pTemp->pLeft || pTemp->pRight)) {
		if (pTemp->Data > data) {
			if (pTemp->pLeft) 
				pTemp = pTemp->pLeft;
			else {
				pTemp->pLeft = pNode;
				return;
			}
		}
		else {
			if (pTemp->pRight) 
				pTemp = pTemp->pRight;
			else {
				pTemp->pRight = pNode;
				return;
			}
		}
	}

	if (pTemp->Data > data) 
		pTemp->pLeft = pNode;
	else
		pTemp->pRight = pNode;


}

//Ещё один пример перебора всех элементов дерева: Функция перебора всех узлов в дереве, вывод дерева
void Recursion(Node* pTemp)
{
	if (!pTemp->pLeft && !pTemp->pRight) { //Нет способа получить узел ниже, значит нынешний узел крайний нижний в этой ветке
		std::cout << pTemp->Data << " ";
		return;
	}
	//Поиск крайнего левого нижнего узла, игнорируя правую ветку
	if(pTemp->pLeft)//Узлы левее имеют больший приоритет
		Recursion(pTemp->pLeft); //Если есть способ получить узел левее, значит нынешний узел не крайний нижний левый

	//Крайний левый нижний узел для данной ветки найден

	std::cout << pTemp->Data << " "; //Вывод нынешнего узла
	if (pTemp->pRight)//Если есть способ получить узел правее (узлов левее больше нет), значит нынешний узел не крайний нижний для этой ветки
		Recursion(pTemp->pRight); //Вход в правую ветку
}

void Tree::PrintTree()
{
	Recursion(pHead);
	std::cout << std::endl;
}




